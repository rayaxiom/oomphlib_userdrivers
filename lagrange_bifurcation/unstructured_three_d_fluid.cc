//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Driver code for a simple unstructured fluid problem using a mesh
// generated from an input file generated by the 3d mesh generator
// tetgen


//Generic routines
#include "generic.h"
#include "constitutive.h"
#include "navier_stokes.h"

// My own header
#include "./../rayheader.h"

// Get the mesh
#include "meshes/tetgen_mesh.h"
#include "meshes/brick_from_tet_mesh.h" // RAYRAY new brick mesh stuff

using namespace std;
using namespace oomph;

enum MeshType { HEXAHEDRAL, TETRAHEDRAL};

namespace RayNamespace
{
  // CL - set directly from the commandline.
  // To set from CL - a CL value is set, this is changed depending on that
  // value.

  double Mesh_area = 0.0;
  std::string Mesh_folder_str = "";

  // Set the defaults.
  unsigned Mesh_type = 0; // SL, 0 = TET, 1 = HEX
  unsigned W_solver = 0; //CL, 0 = SuperLU, no other W solver coded.
  unsigned NS_solver = 1; //CL, 0 = SuperLU, 1 - LSC
  unsigned F_solver = 0; //CL, 0 - SuperLU, 1 - AMG
  unsigned P_solver = 0; //CL, 0 - SuperLU, 1 - AMG
  unsigned Vis = 0; //CL, 0 - Simple, 1 - Stress divergence
  double Rey = 100.0; //CL, Reynolds number
  double Scaling_sigma = 0; //CL, If the scaling sigma is not set, then
                             // the default is the norm of the momentum block.
  
  // The are the time step parameters. 
  double T_min = 0; // Max time.
  double T_max = 0.5; // Min time.
  double Dt = -1; // if this is set, Ntsteps must not be set.
  int Ntsteps = -1; // if this is set, Dt must not be set.


  std::string Prob_str = "Bi"; //Set from CL, a unique identifier.
  std::string Mesh_str = "Tet"; //Set from CL, Tet or Hex
  std::string W_str = "We"; //Set from CL, e - Exact(LU), no other solver.
  std::string NS_str = "Nl"; //Set from CL, e - Exact, l - LSC
  std::string F_str = "Fe"; //Set from CL, e - Exact, a - AMG
  std::string P_str = "Pe"; //Set from CL, e - Exact, a - AMG
  std::string Vis_str = "Sim"; //Set from CL, Sim - Simple, Str = Stress Diver.
  std::string Rey_str = "R100"; //Set from CL, Reynolds number
  std::string Sigma_str = ""; //Set from CL, sigma being used. is norm, then is
                              // null.
  std::string W_approx_str=""; //Set from CL, use diagonal approximation for W
                               // block?
  bool Use_axnorm = true; //Set from CL, use norm for sigma?
  bool Use_diagonal_w_block = true; // To set from CL
  bool Doc_prec = false; // To set from CL
  bool Doc_soln = false; // To set from CL
  bool Print_hypre = true;
  
  std::string Label = ""; // To be set as the label for this problem. Contains
                          // all the information for this run.
  std::string Soln_dir = ""; // Where to put the solution.
  std::string Doc_prec_dir = ""; // Where to put the solution.

  std::string Itstime_dir = ""; //Set from CL, directory to output the 
                                // iteration counts and timing results.

  // Used to determine if we are using the TrilinosAztecOOSolver solver or not.
  // This cannot be determined by the OOMPH_HAS_TRILINOS ifdef since we may be
  // using OOMPH-LIB's GMRES even if we have Trilinos. This should be set in
  // the problem constuctor as soon as we set the linear_solver_pt() for the
  // problem.
  bool Using_trilinos_solver = false;

  double Rey_start = 0.0;
  double Rey_incre = 50.0;
  double Rey_end = 500.0;

  // Object to store the linear solver iterations and times.
  DocLinearSolverInfo* Doc_linear_solver_info_pt;

  unsigned Soln_num = 0;

  double f_amg_strength = -1.0;
  double f_amg_damping = -1.0;
  int f_amg_coarsening = -1;
  int f_amg_smoother = -1;
  int f_amg_iterations = -1;
  int f_amg_smoother_iterations = -1;
  
  double p_amg_strength = -1.0;
  double p_amg_damping = -1.0;
  int p_amg_coarsening = -1;
  int p_amg_smoother = -1;
  int p_amg_iterations = -1;
  int p_amg_smoother_iterations = -1;

  MeshType myMeshType = TETRAHEDRAL;

}

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////


//=======start_namespace==========================================
/// Global variables
//================================================================
namespace Global_Parameters
{
 /// Magnitude of fluid pressure on inflow boundary
 double P_in=1.0;
// double P_in=0.5;

 /// Period
 double Period = 1.0;

 /// Applied traction on fluid at the inflow boundary
 void prescribed_inflow_traction(const double& t,
                                 const Vector<double>& x,
                                 const Vector<double>& n,
                                 Vector<double>& traction)
 {
  // RAYRAY - this does not make sense at the boundaries...
  traction[0]=0.0;
  traction[1]=0.0;
  traction[2]=P_in*(1.0 - cos((2.0*MathematicalConstants::Pi*t)/Period));
  // traction[2]=P_in;
 } 


 /// Fluid pressure on outflow boundary
//  double P_out=-0.5; 

//  /// Applied traction on fluid at the inflow boundary
//  void prescribed_outflow_traction(const double& t,
//                                   const Vector<double>& x,
//                                   const Vector<double>& n,
//                                   Vector<double>& traction)
//  {
//   // RAYRAY - What do I do here?
//   traction[0]=0.0;
//   traction[1]=0.0;
//   //traction[2]= - P_in*(1.0 - cos((2.0*MathematicalConstants::Pi*t)/Period));
//   //traction[2]=-P_out;
//  } 


 bool Impulsive_start_flag = true;
 
} //end Global_Parameters namespace






//======start_problem_class===========================================
/// Unstructured fluid problem
//====================================================================
template<class ELEMENT>
class UnstructuredFluidProblem : public Problem
{

public:

 /// Constructor: 
 UnstructuredFluidProblem();

 /// Destructor (empty)
 ~UnstructuredFluidProblem(){}

 /// Update before solve is empty
 void actions_before_newton_solve()
 {
   // Initialise counters for each newton solve.
   Doc_linear_solver_info_pt->setup_new_time_step();
 }

 void actions_after_newton_step()
 {
   unsigned iters = 0;
   double preconditioner_setup_time = 0.0;
   double solver_time = 0.0;

   // Get the iteration counts.
#ifdef PARANOID
   IterativeLinearSolver* iterative_solver_pt
     = dynamic_cast<IterativeLinearSolver*>
       (this->linear_solver_pt());
   if(iterative_solver_pt == 0)
   {
     std::ostringstream error_message;
     error_message << "Cannot cast the solver pointer." << std::endl;

     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
   }
   else
   {
     iters = iterative_solver_pt->iterations();
     preconditioner_setup_time 
       = iterative_solver_pt->preconditioner_pt()->setup_time();
   }
#else
   iters = static_cast<IterativeLinearSolver*>
             (this->linear_solver_pt())->iterations();
   preconditioner_setup_time = static_cast<IterativeLinearSolver*>
             (this->linear_solver_pt())->preconditioner_pt()->setup_time();

#endif

   // Get the preconditioner setup time.

   // Set the solver time.
   if(RayNamespace::Using_trilinos_solver)
   {
     TrilinosAztecOOSolver* trilinos_solver_pt 
       = dynamic_cast<TrilinosAztecOOSolver*>(this->linear_solver_pt());
     solver_time = trilinos_solver_pt->linear_solver_solution_time();
   }
   else
   {
     solver_time = linear_solver_pt()->linear_solver_solution_time();
   }

   Doc_linear_solver_info_pt->add_iteration_and_time
     (iters,preconditioner_setup_time,solver_time);
 }

 void actions_before_adapt()
 {
   // Kill the flux elements and wipe the mesh
   delete_flux_elements(Fluid_traction_mesh_pt);
   delete_flux_elements(Outflow_surface_mesh_pt);

   // Rebuild the Problem's global mesh from it's various sub-meshes
   rebuild_global_mesh();
 }

 void actions_after_adapt()
 {
   // Create prescribed-flux elements from all elements that are
   // adjacent to...
   create_parall_outflow_lagrange_elements(Outflow_boundary_id[0],
                                           Fluid_mesh_pt,
                                           Outflow_surface_mesh_pt);
   create_parall_outflow_lagrange_elements(Outflow_boundary_id[1],
                                           Fluid_mesh_pt,
                                           Outflow_surface_mesh_pt);
   create_fluid_traction_elements(Inflow_boundary_id[0],
                                  Fluid_mesh_pt,
                                  Fluid_traction_mesh_pt);

   rebuild_global_mesh();

   // Doc refinement levels in bulk mesh
   // Doc refinement levels in bulk mesh
//   unsigned min_refinement_level;
//   unsigned max_refinement_level;
//   Fluid_mesh_pt->get_refinement_levels(min_refinement_level,
//                                     max_refinement_level); 
//   oomph_info << "Min/max. refinement levels in bulk mesh: " 
//              << min_refinement_level << " " 
//              << max_refinement_level << std::endl;

 }

  /// \short Actions before distribute: Wipe the mesh of prescribed flux elements
 /// (simply call actions_before_adapt() which does the same thing)
 void actions_before_distribute()
 {
   actions_before_adapt();
 }

  /// \short Actions after distribute: Rebuild the mesh of prescribed flux 
 /// elements (simply call actions_after_adapt() which does the same thing)
 void actions_after_distribute()
 {
   actions_after_adapt();
 }

 void delete_flux_elements(Mesh* const surface_mesh_pt)
 {
   // How many surface elements are in the surface mesh
   unsigned n_element = surface_mesh_pt->nelement();

   // Loop over the surface elements
   for(unsigned e=0;e<n_element;e++)
   {
     // Kill surface element
     delete surface_mesh_pt->element_pt(e);
   }
   // Wipe surface mesh
   surface_mesh_pt->flush_element_and_node_storage();
 }

 /// Doc the solution
 void doc_solution();

 /// Run an unsteady simulation
 void unsteady_run(); 
 
 /// Return total number of fluid inflow traction boundaries
 unsigned nfluid_inflow_traction_boundary()
  {
   return Inflow_boundary_id.size();
  }

 /// Return total number of fluid outflow traction boundaries
 unsigned nfluid_outflow_traction_boundary()
  {
   return Outflow_boundary_id.size();
  }

 /// Return total number of fluid outflow traction boundaries
 unsigned nfluid_traction_boundary()
  {
   //return Inflow_boundary_id.size()+Outflow_boundary_id.size();
   //return Inflow_boundary_id.size();
   return -1;
  }

 //private:

 /// Create fluid traction elements at inflow
 void create_fluid_traction_elements(const unsigned &b,
                                     Mesh* const &bulk_mesh_pt,
                                     Mesh* const &surface_mesh_pt);

 void create_parall_outflow_lagrange_elements(const unsigned &b,
                                              Mesh* const &bulk_mesh_pt,
                                              Mesh* const &surface_mesh_pt);

 Mesh* Fluid_mesh_pt;

 /// Bulk fluid mesh
 //BrickFromTetMesh<ELEMENT>* Fluid_mesh_pt; // RAYRAY new brick mesh stuff
 //TetgenMesh<ELEMENT>* Fluid_mesh_pt;

 /// Meshes of fluid traction elements that apply pressure at in/outflow
 Mesh* Outflow_surface_mesh_pt;
 Mesh* Fluid_traction_mesh_pt;

 Vector<double> Tangent_direction;

 /// \short IDs of fluid mesh boundaries along which inflow boundary conditions
 /// are applied
 Vector<unsigned> Inflow_boundary_id;

 /// \short IDs of fluid mesh boundaries along which inflow boundary conditions
 /// are applied
 Vector<unsigned> Outflow_boundary_id;

 /// Trace file
 ofstream Trace_file;

 // Preconditioner
 Preconditioner* Prec_pt;
 // Solver
 IterativeLinearSolver* Solver_pt;

 DocLinearSolverInfo* Doc_linear_solver_info_pt;

};



//==========start_constructor=============================================
/// Constructor for unstructured 3D fluid problem
//========================================================================
template<class ELEMENT>
UnstructuredFluidProblem<ELEMENT>::UnstructuredFluidProblem()
{  
 // Alias namespace for convenience
 namespace RNS = RayNamespace;

 Doc_linear_solver_info_pt = RNS::Doc_linear_solver_info_pt;

 // RAYRAY
 // Allocate the timestepper
 add_time_stepper_pt(new BDF<2>);

 //Create fluid bulk mesh, sub-dividing "corner" elements
 string mesh_folder = "tetgen_files/" + RNS::Mesh_folder_str + "/";
 string node_file_name=mesh_folder+"fsi_bifurcation_fluid.1.node";
 string element_file_name=mesh_folder+"fsi_bifurcation_fluid.1.ele";
 string face_file_name=mesh_folder+"fsi_bifurcation_fluid.1.face";
 bool split_corner_elements=true;

 // RAYRAY new brick mesh stuff
 if(RNS::myMeshType == HEXAHEDRAL)
  {
   oomph_info << "Doing HEXAHEDRAL" << std::endl; 
   
   Fluid_mesh_pt =  new BrickFromTetMesh<ELEMENT>(node_file_name,
                                                  element_file_name,
                                                  face_file_name,
                                                  split_corner_elements,
                                                  time_stepper_pt());
  }
 else if(RNS::myMeshType == TETRAHEDRAL)
  {
   oomph_info << "Doing TETRAHEDRAL" << std::endl; 
   
   Fluid_mesh_pt =  new TetgenMesh<ELEMENT>(node_file_name,
                                            element_file_name,
                                            face_file_name,
                                            split_corner_elements,
                                            time_stepper_pt());
  }
 else
  {
   std::ostringstream err_msg;
   err_msg << "No such mesh shapes." << std::endl;

   throw OomphLibError(err_msg.str(),
                       OOMPH_CURRENT_FUNCTION,
                       OOMPH_EXCEPTION_LOCATION);
  }


 // Find elements next to boundaries
 //Fluid_mesh_pt->setup_boundary_element_info();

 // The following corresponds to the boundaries as specified by
 // facets in the tetgen input:

 // Fluid mesh has one inflow boundary: Boundary 0
 Inflow_boundary_id.resize(1);
 Inflow_boundary_id[0]=0;
 
 // Fluid mesh has two outflow boundaries: Boundaries 1 and 2
 Outflow_boundary_id.resize(2);
 Outflow_boundary_id[0]=1;
 Outflow_boundary_id[1]=2;
 
 // Apply BCs
 //----------
 
 // Map to indicate which boundary has been done
 std::map<unsigned,bool> done; 
 
 {
  // There is only one inflow boundary.
  unsigned b=Inflow_boundary_id[0];

  // Number of nodes on that boundary
  unsigned num_nod=Fluid_mesh_pt->nboundary_node(b);
  for (unsigned inod=0;inod<num_nod;inod++)
   {
    // Get the node
    Node* nod_pt=Fluid_mesh_pt->boundary_node_pt(b,inod);
  
    // Pin transverse velocities
    nod_pt->pin(0);
    nod_pt->pin(1);
   }
  // Done!
  done[b]=true;
 }

 // The nodes at the outflow boundary should be free.
 // So we set these to "done".
 unsigned n_outflow_b = nfluid_outflow_traction_boundary();
 for (unsigned b = 0; b < n_outflow_b; b++) 
  {
   unsigned outflow_b = Outflow_boundary_id[b];
   done[outflow_b] = true;
  }
 
 
 // Loop over all fluid mesh boundaries and pin velocities
 // of nodes that haven't been dealt with yet
 unsigned nbound=Fluid_mesh_pt->nboundary();
 for(unsigned b=0;b<nbound;b++)
  {

   // Has the boundary been done yet?
   if (!done[b])
    {
     unsigned num_nod=Fluid_mesh_pt->nboundary_node(b);
     for (unsigned inod=0;inod<num_nod;inod++)
      {
       // Get node
       Node* nod_pt= Fluid_mesh_pt->boundary_node_pt(b,inod);
       
       // Pin all velocities
       nod_pt->pin(0); 
       nod_pt->pin(1); 
       nod_pt->pin(2); 
      }
    }

  } // done no slip elsewhere 
 
 // Complete the build of the fluid elements so they are fully functional
 //----------------------------------------------------------------------
 unsigned n_element = Fluid_mesh_pt->nelement();
 for(unsigned e=0;e<n_element;e++)
  {
   // Upcast from GeneralisedElement to the present element
   ELEMENT* el_pt = dynamic_cast<ELEMENT*>(Fluid_mesh_pt->element_pt(e));
   
   //Set the Reynolds number
   el_pt->re_pt() = &RNS::Rey;   
  } 
 
 
 // Create meshes of fluid traction elements at inflow/outflow
 //-----------------------------------------------------------
 
 // Create the meshes
 Fluid_traction_mesh_pt=new Mesh;
 Outflow_surface_mesh_pt = new Mesh;
 // Populate them with elements
 create_fluid_traction_elements(Inflow_boundary_id[0],
                                Fluid_mesh_pt,
                                Fluid_traction_mesh_pt);

 // Setup the tangent direction.
 Tangent_direction.resize(3,0);
 Tangent_direction[0] = 0;
 Tangent_direction[1] = 1;
 Tangent_direction[2] = 0;
 create_parall_outflow_lagrange_elements(Outflow_boundary_id[0],
                                         Fluid_mesh_pt,
                                         Outflow_surface_mesh_pt);
 create_parall_outflow_lagrange_elements(Outflow_boundary_id[1],
                                         Fluid_mesh_pt,
                                         Outflow_surface_mesh_pt);

 
 // Combine the lot
 //----------------
 
 // Add sub meshes:

 // Fluid bulk mesh
 add_sub_mesh(Fluid_mesh_pt);
 
 // The fluid traction meshes
 add_sub_mesh(Fluid_traction_mesh_pt);
 add_sub_mesh(Outflow_surface_mesh_pt);
 
 // Build global mesh
 build_global_mesh();

 // Setup equation numbering scheme
 oomph_info <<"Number of equations: " << assign_eqn_numbers() << std::endl; 

 ///////////////////////////////////////////////////////////
 ////// Build the preconditioner
 LagrangeEnforcedflowPreconditioner* prec_pt
   = new LagrangeEnforcedflowPreconditioner;
 
 Prec_pt = prec_pt;

 Vector<Mesh*> mesh_pt;
 mesh_pt.resize(2);
 mesh_pt[0] = Fluid_mesh_pt;
 mesh_pt[1] = Outflow_surface_mesh_pt;
 prec_pt->set_meshes(mesh_pt);

 oomph_info << "From driver: mesh_pt 0, nelement: " << mesh_pt[0]->nelement() << std::endl; 
 oomph_info << "From driver: mesh_pt 1, nelement: " << mesh_pt[1]->nelement() << std::endl; 
 

 if(!RNS::Use_axnorm)
 {
   prec_pt->scaling_sigma() = RNS::Scaling_sigma;
 }

 // W solver. Use SuperLU
 if(RNS::W_solver == 0)
 {
 }
 else
 {
   oomph_info << "Other W solvers not complemented yet. Using default SuperLU"
              << std::endl;
 }

 // The preconditioner for the fluid block:
 if(RNS::NS_solver == 0) // Exact solve.
 {}
 else if(RNS::NS_solver == 1) // LSC
 {
   NavierStokesSchurComplementPreconditioner* ns_preconditioner_pt =
     new NavierStokesSchurComplementPreconditioner(this);

   prec_pt->set_navier_stokes_lsc_preconditioner(ns_preconditioner_pt);
   ns_preconditioner_pt->set_navier_stokes_mesh(Fluid_mesh_pt);

   // F block solve
   // Preconditioner for the F block:
   Preconditioner* f_preconditioner_pt = 0;
   // RNS::F_solver == 0 is default, so do nothing.
   if(RNS::F_solver == 11)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_2D_poison_problem();
#endif
   }
   else if(RNS::F_solver == 12)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_navier_stokes_momentum_block();
#endif
   }
   else if(RNS::F_solver == 13)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_CLJPGSStrn075();
#endif
   }
   else if(RNS::F_solver == 14)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_RSGSStrn075();
#endif
   }
   else if(RNS::F_solver == 15)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_CLJPPilutStrn075();
#endif
   }
   else if(RNS::F_solver == 16)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_RSPilutStrn075();
#endif
   }
   else if(RNS::F_solver == 17)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_augmented_momentum_block();
#endif
   }
   else if(RNS::F_solver == 81)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_CLJPGSStrn0668();
#endif
   }
   else if(RNS::F_solver == 82)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_CLJPJStrn0668();
#endif
   }
   else if(RNS::F_solver == 83)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_CLJPPilutStrn0668();
#endif
   }
   else if(RNS::F_solver == 84)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_RSGSStrn0668();
#endif
   }
   else if(RNS::F_solver == 85)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_RSJStrn0668();
#endif
   }
   else if(RNS::F_solver == 86)
   {
#ifdef OOMPH_HAS_HYPRE
     // LSC takes type "Preconditioner".
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_for_RSPilutStrn0668();
#endif
   }
   else if(RNS::F_solver == 2)
   {
//     f_preconditioner_pt = new RayBlockDiagonalPreconditioner<CRDoubleMatrix>;
     f_preconditioner_pt = new BlockDiagonalPreconditioner<CRDoubleMatrix>;
   }
   else if(RNS::F_solver == 3)
   {
     f_preconditioner_pt = new BlockDiagonalPreconditioner<CRDoubleMatrix>;
#ifdef OOMPH_HAS_HYPRE
     dynamic_cast<BlockDiagonalPreconditioner<CRDoubleMatrix>* >
       (f_preconditioner_pt)->set_subsidiary_preconditioner_function
       (Hypre_Subsidiary_Preconditioner_Helper::set_hypre_for_2D_poison_problem);
#endif
   }
   else if (RNS::F_solver == 69)
   {
#ifdef OOMPH_HAS_HYPRE
     // AMG coarsening: Ruge-Stuben
     RayGlobalAMGParam::amg_coarsening = 1;
     
     // AMG smoother: Gauss-Seidel
     RayGlobalAMGParam::amg_smoother=0;
     
     // There is no damping with GS, otherwise we set the parameter:
     // RayParam::amg_damping

     // Different amg strength for simple/stress divergence for viscuous term.
     if(RNS::Vis == 0)
     {
       // Simple form
       RayGlobalAMGParam::amg_strength = 0.25;
     }
     else
     {
       // Stress divergence form
       RayGlobalAMGParam::amg_strength = 0.668;
     }
     
     // Setup the preconditioner.
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_using_2D_poisson_base();
#endif
   }
   else if (RNS::F_solver == 96)
   {
#ifdef OOMPH_HAS_HYPRE
     // AMG coarsening:
     // Set: RayGlobalAMGParam::amg_coarsening = 
     // 0 - CLJP
     // 1 - RS
     
     // AMG smoother:
     // Set: RayGlobalAMGParam::amg_smoother = 
     // 0 - Jacobi (Need to set damping as well)
     // 1 - Gauss-Seidel
     // 2 - Pilut
     
     // There is no damping with GS, otherwise we set the parameter:
     // RayGlobalAMGParam::amg_damping

     RayGlobalAMGParam::amg_strength = RNS::f_amg_strength;
     RayGlobalAMGParam::amg_damping = RNS::f_amg_damping;
     RayGlobalAMGParam::amg_coarsening = RNS::f_amg_coarsening;
     RayGlobalAMGParam::amg_smoother = RNS::f_amg_smoother;
     RayGlobalAMGParam::amg_iterations = RNS::f_amg_iterations;
     RayGlobalAMGParam::amg_smoother_iterations = RNS::f_amg_smoother_iterations;


     // Different amg strength for simple/stress divergence for viscuous term.
     if(RayGlobalAMGParam::amg_strength < 0.0)
     {
       if(RNS::Vis == 0)
       {
         // Simple form
         RayGlobalAMGParam::amg_strength = 0.25;
       }
       else
       {
         // Stress divergence form
         RayGlobalAMGParam::amg_strength = 0.668;
       }
     }
     
     // Setup the preconditioner.
     f_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::
       set_hypre_ray();
#endif
   }

   // Set the preconditioner in the LSC preconditioner.
   ns_preconditioner_pt->set_f_preconditioner(f_preconditioner_pt);
   
   // P block solve
   //RNS::P_solver == 0 is default, so do nothing.
   if(RNS::P_solver == 1)
   {
#ifdef OOMPH_HAS_HYPRE
     Preconditioner* p_preconditioner_pt = new HyprePreconditioner;

     HyprePreconditioner* hypre_preconditioner_pt =
       static_cast<HyprePreconditioner*>(p_preconditioner_pt);

     Hypre_default_settings::
     set_defaults_for_3D_poisson_problem(hypre_preconditioner_pt);

     ns_preconditioner_pt->set_p_preconditioner(p_preconditioner_pt);
#endif
   }
   else if(RNS::P_solver == 96)
   {
#ifdef OOMPH_HAS_HYPRE
     Preconditioner* p_preconditioner_pt = 0;
     
//* 
     RayGlobalAMGParam::amg_iterations = RNS::p_amg_iterations;
     RayGlobalAMGParam::amg_smoother_iterations = RNS::p_amg_smoother_iterations;
     RayGlobalAMGParam::amg_smoother = RNS::p_amg_smoother;
     RayGlobalAMGParam::amg_strength = RNS::p_amg_strength;
     //RayGlobalAMGParam::amg_damping = RNS::p_amg_damping;
     RayGlobalAMGParam::amg_coarsening = RNS::p_amg_coarsening;

//     oomph_info << "p_amg_iterations:" << SL::p_amg_iterations << std::endl; 
//     oomph_info << "p_amg_smoother_iterations" << SL::p_amg_smoother_iterations << std::endl; 
//     oomph_info << "p_amg_strength" << SL::p_amg_strength << std::endl;
//     oomph_info << "p_amg_coarsening" << SL::p_amg_coarsening << std::endl; 
// */

     p_preconditioner_pt = Hypre_Subsidiary_Preconditioner_Helper::set_hypre_ray();

     ns_preconditioner_pt->set_p_preconditioner(p_preconditioner_pt);
#endif
   }
 } // if for using LSC as NS prec.
 else
 {
   pause("There is no solver for NS.");
 }

 // Set the doc info for book keeping purposes.
 prec_pt->set_doc_linear_solver_info_pt(RNS::Doc_linear_solver_info_pt);

 if(RNS::Use_diagonal_w_block)
 {
   prec_pt->use_diagonal_w_block();
 }
 else
 {
   prec_pt->use_block_diagonal_w_block();
 }

 if(RNS::Doc_prec)
 {
   prec_pt->enable_doc_prec();
 }

 // Set the label, use to output information from the preconditioner, such
 // as the block matrices and the rhs vector
 prec_pt->set_label_pt(&RNS::Label);
 prec_pt->set_doc_prec_directory_pt(&RNS::Doc_prec_dir);

 // Build solve and preconditioner
//#ifdef OOMPH_HAS_TRILINOS
// TrilinosAztecOOSolver* trilinos_solver_pt = new TrilinosAztecOOSolver;
// trilinos_solver_pt->solver_type() = TrilinosAztecOOSolver::GMRES;
// Solver_pt = trilinos_solver_pt;
// RNS::Using_trilinos_solver = true;
//#else
 Solver_pt = new GMRES<CRDoubleMatrix>;
 // We use RHS preconditioning. Note that by default,
 // left hand preconditioning is used.
 static_cast<GMRES<CRDoubleMatrix>*>(Solver_pt)->set_preconditioner_RHS();
 RNS::Using_trilinos_solver = false;
//#endif

 Solver_pt->tolerance() = 1.0e-6;
 this->newton_solver_tolerance() = 1.0e-6;

 // Set solver and preconditioner
 Solver_pt->preconditioner_pt() = Prec_pt;
 linear_solver_pt() = Solver_pt;
} // end constructor

//============start_of_fluid_traction_elements==============================
/// Create fluid traction elements 
//=======================================================================
template<class ELEMENT>
void UnstructuredFluidProblem<ELEMENT>::create_fluid_traction_elements
(const unsigned &b, Mesh* const &bulk_mesh_pt, Mesh* const &surface_mesh_pt)
{
 // How many bulk elements are adjacent to boundary b?
 unsigned n_element = Fluid_mesh_pt->nboundary_element(b);
   
 // Loop over the bulk elements adjacent to boundary b
 for(unsigned e=0;e<n_element;e++)
  {
   // Get pointer to the bulk element that is adjacent to boundary b
   ELEMENT* bulk_elem_pt = dynamic_cast<ELEMENT*>(
    Fluid_mesh_pt->boundary_element_pt(b,e));
     
   //What is the index of the face of the element e along boundary b
   int face_index = Fluid_mesh_pt->face_index_at_boundary(b,e);

   // Set the pointer to the prescribed traction function
   {      
    // Create new element 
    NavierStokesTractionElement<ELEMENT>* el_pt=
     new NavierStokesTractionElement<ELEMENT>(bulk_elem_pt,
                                              face_index);
       
    // Add it to the mesh
    Fluid_traction_mesh_pt->add_element_pt(el_pt);

    el_pt->traction_fct_pt() = 
     &Global_Parameters::prescribed_inflow_traction;
   }
  }
} // end of create_fluid_traction_elements

//============start_of_fluid_traction_elements==============================
/// Create fluid traction elements 
//=======================================================================
template<class ELEMENT>
void UnstructuredFluidProblem<ELEMENT>::create_parall_outflow_lagrange_elements
(const unsigned &b, Mesh* const &bulk_mesh_pt, Mesh* const &surface_mesh_pt)
{
 // How many bulk elements are adjacent to boundary b?
 unsigned n_element = Fluid_mesh_pt->nboundary_element(b);
   
 // Loop over the bulk elements adjacent to boundary b
 for(unsigned e=0;e<n_element;e++)
  {
   // Get pointer to the bulk element that is adjacent to boundary b
   ELEMENT* bulk_elem_pt = dynamic_cast<ELEMENT*>(
    Fluid_mesh_pt->boundary_element_pt(b,e));
     
   //What is the index of the face of the element e along boundary b
   int face_index = Fluid_mesh_pt->face_index_at_boundary(b,e);

   // Set the pointer to the prescribed traction function
   {
    // Build the corresponding impose_impenetrability_element
    ImposeParallelOutflowElement<ELEMENT>* flux_element_pt = new
     ImposeParallelOutflowElement<ELEMENT>(bulk_elem_pt,
                                           face_index);

    flux_element_pt->set_tangent_direction(&Tangent_direction);
    Outflow_surface_mesh_pt->add_element_pt(flux_element_pt);

    // Loop over the nodes
    unsigned nnod=flux_element_pt->nnode();
    for (unsigned j=0;j<nnod;j++)
     {
      Node* nod_pt = flux_element_pt->node_pt(j);
           
      // Determine which outflow boundary it is, left or right?
           
      if (  (nod_pt->is_on_boundary(7))||(nod_pt->is_on_boundary(8))
            ||(nod_pt->is_on_boundary(9))||(nod_pt->is_on_boundary(10))
            ||(nod_pt->is_on_boundary(11))||(nod_pt->is_on_boundary(12))
            ||(nod_pt->is_on_boundary(13))||(nod_pt->is_on_boundary(14)))
       {
        // How many nodal values were used by the "bulk" element
        // that originally created this node?
        unsigned n_bulk_value=flux_element_pt->nbulk_value(j);

        // The remaining ones are Lagrange multipliers and we pin them.
        unsigned nval=nod_pt->nvalue();
        for (unsigned j=n_bulk_value;j<nval;j++)
         {
          nod_pt->pin(j);
         }
       }
     }
   }
  }
} // end of create_parall_outflow_lagrange_elements


//========================================================================
/// Doc the solution
//========================================================================
template<class ELEMENT>
void UnstructuredFluidProblem<ELEMENT>::doc_solution()
{ 
 namespace RNS = RayNamespace;

 std::ofstream some_file;
 std::stringstream filename;
 filename << RNS::Soln_dir<<"/soln"<<RNS::Soln_num<<".dat";

 // Number of plot points
 unsigned npts = 5;
 
 // Output fluid solution
 some_file.open(filename.str().c_str());
 Fluid_mesh_pt->output(some_file,npts);
 some_file.close();
}

//========================================================================
/// Unsteady run...
//========================================================================
template<class ELEMENT>
void UnstructuredFluidProblem<ELEMENT>::unsteady_run()
{
 namespace RNS = RayNamespace;

 // Open trace file
 std::stringstream filename;
 filename << RNS::Soln_dir << "/trace.dat";

 Trace_file.open(filename.str().c_str());

 Trace_file << "Hello!\n";

 // Period is 1.0
 //double time_max = Global_Parameters::Period / 2.0; // time_max = 0.5
 //double time_min = 0;
 //unsigned ntsteps = 40;

 //time_max /=4;
 //time_min /=4;
 //ntsteps /=4;
 //double dt = (time_max - time_min)/ntsteps;

 if(Global_Parameters::Impulsive_start_flag)
  {
   assign_initial_values_impulsive(RNS::Dt);
   oomph_info << "IC = impulsive start" << std::endl;
   oomph_info << "T_min = " << RNS::T_min << std::endl;
   oomph_info << "T_max = " << RNS::T_max << std::endl;
   oomph_info << "Dt = " << RNS::Dt << std::endl;
   oomph_info << "Ntsteps = " << RNS::Ntsteps << std::endl;
  }

 oomph_info << "RNS::Doc_soln: " << RNS::Doc_soln << std::endl;
 oomph_info << "RNS::Soln_dir: " << RNS::Soln_dir << std::endl; 
 
 
 // Doc initial condition
 if(RNS::Doc_soln)
 {
   doc_solution();

   // increment counter
   RNS::Soln_num++;
 }

 // Loop over timesteps
 for (int t = 0; t < RNS::Ntsteps; t++) 
  {
   oomph_info << "TIMESTEP " << t << std::endl; 
    
   // Take one fixed timestep
   unsteady_newton_solve(RNS::Dt);

   // Output the time
   oomph_info << "Time is now " << time_pt()->time() << std::endl; 
   
   if(RNS::Doc_soln)
   {
   // Doc solution
   doc_solution();

   // increment counter
   RNS::Soln_num++;
   }
  }
  
} // EoFunc unsteady_run()

double round(double d)
{
  return floor(d + 0.5);
}

//=============start_main=================================================
/// Demonstrate how to solve an unstructured 3D fluids problem
//========================================================================
int main(int argc, char **argv)
{
#ifdef OOMPH_HAS_MPI
 // Initialise MPI
 MPI_Helpers::init(argc,argv);
#endif

 // Alias namespace for convenience
 namespace RNS = RayNamespace;

 // Set up doc info
 DocLinearSolverInfo doc_linear_solver_info;
 
 RNS::Doc_linear_solver_info_pt = &doc_linear_solver_info;

 RNS::Soln_dir = "RESLT";

 RNS::Doc_prec_dir = "rawdata";

 // Store command line arguments
 CommandLineArgs::setup(argc,argv);
 

 // Flag to output the solution.
 CommandLineArgs::specify_command_line_flag("--doc_soln", &RNS::Soln_dir);
 // Flag to output the preconditioner, used for debugging.
 CommandLineArgs::specify_command_line_flag("--doc_prec",
                                            &RNS::Doc_prec_dir);

 // Mesh parameter
 CommandLineArgs::specify_command_line_flag("--mesh_type", &RNS::Mesh_type);
 CommandLineArgs::specify_command_line_flag("--mesh_area", &RNS::Mesh_area);

 // Time stepping parameters.
 CommandLineArgs::specify_command_line_flag("--t_min", &RNS::T_min);
 CommandLineArgs::specify_command_line_flag("--t_max", &RNS::T_max);
 CommandLineArgs::specify_command_line_flag("--dt", &RNS::Dt);
 CommandLineArgs::specify_command_line_flag("--ntsteps", &RNS::Ntsteps);

 
 // Problem/solver parameters
 CommandLineArgs::specify_command_line_flag("--w_solver", &RNS::W_solver);
 CommandLineArgs::specify_command_line_flag("--ns_solver", &RNS::NS_solver);
 CommandLineArgs::specify_command_line_flag("--p_solver", &RNS::P_solver);
 CommandLineArgs::specify_command_line_flag("--f_solver", &RNS::F_solver);
 CommandLineArgs::specify_command_line_flag("--visc", &RNS::Vis);
 CommandLineArgs::specify_command_line_flag("--rey", &RNS::Rey);
 CommandLineArgs::specify_command_line_flag("--rey_start", &RNS::Rey_start);
 CommandLineArgs::specify_command_line_flag("--rey_incre", &RNS::Rey_incre);
 CommandLineArgs::specify_command_line_flag("--rey_end", &RNS::Rey_end);
 CommandLineArgs::specify_command_line_flag("--sigma",
                                            &RNS::Scaling_sigma);
 CommandLineArgs::specify_command_line_flag("--bdw");

 // Iteration count and times directory.
 CommandLineArgs::specify_command_line_flag("--itstimedir", &RNS::Itstime_dir);

 // NS_F block AMG parameters
 CommandLineArgs::specify_command_line_flag("--f_amg_str", &RNS::f_amg_strength);
 CommandLineArgs::specify_command_line_flag("--f_amg_damp", &RNS::f_amg_damping);
 CommandLineArgs::specify_command_line_flag("--f_amg_coarse", &RNS::f_amg_coarsening);
 CommandLineArgs::specify_command_line_flag("--f_amg_smoo", &RNS::f_amg_smoother);
 CommandLineArgs::specify_command_line_flag("--f_amg_iter", &RNS::f_amg_iterations);
 CommandLineArgs::specify_command_line_flag("--f_amg_smiter", &RNS::f_amg_smoother_iterations);

 // NS_P block AMG parameters
 CommandLineArgs::specify_command_line_flag("--p_amg_str", &RNS::p_amg_strength);
 CommandLineArgs::specify_command_line_flag("--p_amg_damp", &RNS::p_amg_damping);
 CommandLineArgs::specify_command_line_flag("--p_amg_coarse", &RNS::p_amg_coarsening);
 CommandLineArgs::specify_command_line_flag("--p_amg_smoo", &RNS::p_amg_smoother);
 CommandLineArgs::specify_command_line_flag("--p_amg_iter", &RNS::p_amg_iterations);
 CommandLineArgs::specify_command_line_flag("--p_amg_smiter", &RNS::p_amg_smoother_iterations);


 // Parse the above flags.
 CommandLineArgs::parse_and_assign();
 CommandLineArgs::doc_specified_flags();

 ////////////////////////////////////////////////////
 // Now set up the flags/parameters for the problem//
 ////////////////////////////////////////////////////
 
 // Time step parameters.
 if(CommandLineArgs::command_line_flag_has_been_set("--dt"))
 {
   if(CommandLineArgs::command_line_flag_has_been_set("--ntsteps"))
   {
     std::ostringstream err_msg;
     err_msg << "Cannot set both --dt and --ntsteps at the same time." 
             << std::endl;
     
     throw OomphLibError(err_msg.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
   }

   // dt has been set, we now work out how many time steps we need to go from
   // T_min to T_max
   RNS::Ntsteps = int(round((RNS::T_max - RNS::T_min)/RNS::Dt));
 }
 else if(CommandLineArgs::command_line_flag_has_been_set("--ntsteps"))
 {
   if(CommandLineArgs::command_line_flag_has_been_set("--dt"))
   {
     std::ostringstream err_msg;
     err_msg << "Cannot set both --dt and --ntsteps at the same time."
             << std::endl;

     throw OomphLibError(err_msg.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
   }

   // ntsteps has been set, we now work out the increment required for
   // ntsteps to take place.
   RNS::Dt = (RNS::T_max - RNS::T_min) / RNS::Ntsteps;
 }
 else
 {
   oomph_info << "No time steps have been provided" << std::endl; 
   RNS::Ntsteps = 40;
   RNS::Dt = (RNS::T_max - RNS::T_min)/RNS::Ntsteps;

   oomph_info << "T_min = " << RNS::T_min << std::endl;
   oomph_info << "T_max = " << RNS::T_max << std::endl;
   oomph_info << "Dt = " << RNS::Dt << std::endl;
   oomph_info << "Ntsteps = " << RNS::Ntsteps << std::endl;
 }


 

 // Document the solution? Default is false.
 if(CommandLineArgs::command_line_flag_has_been_set("--doc_soln"))
 {
   RNS::Doc_soln = true;
 }

 // Document the preconditioner? Default is false.
 if(CommandLineArgs::command_line_flag_has_been_set("--doc_prec"))
 {
   RNS::Doc_prec = true;
 }


 // Set a string to identify the problem. This is unique to each problem,
 // so we hard code this. 2DStrPo = 2 dimension, straight parallel outflow.
 // straight describes the velocity flow field. Po = Parallel outflow
 // describes the boundary type.
 RNS::Prob_str = "Bi";

 // Set the strings to identify the preconditioning,
 // This is used purely for book keeping purposes.
 
 if(CommandLineArgs::command_line_flag_has_been_set("--mesh_area"))
 {
   // Set the string to load the files.
   // The RNS::Mesh_area parameter is a double.
   // The actual mesh files are in tetgen_files/xdyz
   // where d represents the decimal place.
   // So we need to replace the decimal in the RNS::Mesh_area parameter with
   // d.
   std::ostringstream tmp_stringstream;
   tmp_stringstream << RNS::Mesh_area;
   RNS::Mesh_folder_str = tmp_stringstream.str();
   std::replace(RNS::Mesh_folder_str.begin(), RNS::Mesh_folder_str.end(),
                '.','d');

   // Now we check if this folder actually exists.
   // Actually, not doing this as it's better implemented in BOOST and we don't
   // use BOOST (yet!).
 }
 else
 {
     std::ostringstream err_msg;
     err_msg << "You have no set --mesh_area" << std::endl;

     throw OomphLibError(err_msg.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
 }

 // Default: W_solver = 0, W_str = We
 if(CommandLineArgs::command_line_flag_has_been_set("--mesh_type"))
 {
  switch(RNS::Mesh_type)
  {
    case 0:
      RNS::Mesh_str = "Tet";
      RNS::myMeshType = TETRAHEDRAL;
      break;
    case 1:
    {
      RNS::Mesh_str = "Hex";
      RNS::myMeshType = HEXAHEDRAL;
    }
      break;
    default:
    {
     std::ostringstream err_msg;
     err_msg << "No such mesh encoded" << std::endl;

     throw OomphLibError(err_msg.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
  }  // switch
 } // if


 // Default: W_solver = 0, W_str = We
 if(CommandLineArgs::command_line_flag_has_been_set("--w_solver"))
 {
  switch(RNS::W_solver)
  {
    case 0:
      RNS::W_str = "We";
      break;
    case 1:
    {
      pause("No other W block solver coded."); 
      RNS::W_str = "Wa";
    }
      break;
    default:
    {
     std::ostringstream err_msg;
     err_msg << "No such W solver coded: " << RNS::W_solver << std::endl;

     throw OomphLibError(err_msg.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
  }  // switch
 } // if

 // Default: NS_solver = 1, NS_str = Nl
 if(CommandLineArgs::command_line_flag_has_been_set("--ns_solver"))
 {
  switch(RNS::NS_solver)
  {
    case 0:
      RNS::NS_str = "Ne";
      RNS::P_str = "";
      RNS::F_str = "";
      break;
    case 1:
      RNS::NS_str = "Nl";
      break;
    default:
     {
      std::ostringstream err_msg;
      err_msg << "No such NS solver coded: " << RNS::NS_solver << std::endl;

      throw OomphLibError(err_msg.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
  }  // switch
 } // if

 // Default: This can only be set if NS_solver != 0 i.e. we are using LSC for 
 // the NS block
 // Default: P_solver = 0, P_str = Pe
 if(CommandLineArgs::command_line_flag_has_been_set("--p_solver"))
 {
  if(RNS::NS_solver == 0)
  {
    std::ostringstream err_msg;
    err_msg << "NS solver is exact. There cannot be a P solver." << std::endl;

    throw OomphLibError(err_msg.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
  }

  switch(RNS::P_solver)
  {
    case 0:
      RNS::P_str = "Pe";
      break;
    case 1:
      RNS::P_str = "Pa";
      break;
    case 96:
      RNS::P_str = "Pray";
      break;
    default:
     {
      std::ostringstream err_msg;
      err_msg  << "Do not recognise P: " << RNS::P_solver << "\n"
                << "Exact preconditioning = 0\n"
                << "AMG = 1"<< std::endl;

      throw OomphLibError(err_msg.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
  }  // switch
 } // if


 // This can only be set if we're using LSC for the NS block.
 // Default: 0, Fe
 if(CommandLineArgs::command_line_flag_has_been_set("--f_solver"))
 {
  if(RNS::NS_solver == 0)
  {
    std::ostringstream err_msg;
    err_msg << "NS solver is exact. There cannot be a F solver." << std::endl;

    throw OomphLibError(err_msg.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
  }

  switch(RNS::F_solver)
  {
    case 0:
      RNS::F_str = "Fe";
      break;
    case 69:
      RNS::F_str = "Fa";
      break;
    case 96:
      RNS::F_str = "Fray";
      break;
    default:
      {
      std::ostringstream err_msg;
      err_msg << "Do not recognise F: " << RNS::F_solver << "\n"
              << "Exact preconditioning = 0\n"
              << "AMG = xxx Look in the code..."<< std::endl;

      throw OomphLibError(err_msg.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
      }
  }  // switch
 } // if


 // Set the viscuous term.
 // Default: 0, Sim
 if(CommandLineArgs::command_line_flag_has_been_set("--visc"))
 {
   if (RNS::Vis == 0)
   {
     RNS::Vis_str = "Sim";
     NavierStokesEquations<3>::Gamma[0]=0.0;
     NavierStokesEquations<3>::Gamma[1]=0.0;
     NavierStokesEquations<3>::Gamma[2]=0.0;

   }
   else if (RNS::Vis == 1)
   {
     RNS::Vis_str = "Str";
     NavierStokesEquations<3>::Gamma[0]=1.0;
     NavierStokesEquations<3>::Gamma[1]=1.0;
     NavierStokesEquations<3>::Gamma[2]=1.0;
   } // else - setting viscuous term.
   else
   {
     std::ostringstream err_msg;
     err_msg << "Do not recognise Viscuous term: " << RNS::Vis << "\n";

     throw OomphLibError(err_msg.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
   }
 }

 // Set Use_axnorm, if sigma has not been set, norm os momentum block is used.
 if(CommandLineArgs::command_line_flag_has_been_set("--sigma"))
 {
   RNS::Use_axnorm = false;

   std::ostringstream strs;
   strs << "S" << RNS::Scaling_sigma;
   RNS::Sigma_str = strs.str();
 }

 // use the diagonal or block diagonal approximation for W block.
 if(CommandLineArgs::command_line_flag_has_been_set("--bdw"))
 {
   RNS::Use_diagonal_w_block = false;
   RNS::W_approx_str = "bdw";
 }
 else
 {
   RNS::Use_diagonal_w_block = true;
   RNS::W_approx_str = "";
 }

 // Set Rey_str, used for book keeping.
 if(CommandLineArgs::command_line_flag_has_been_set("--rey"))
 {
   if(RNS::Rey >= 0)
   {
     std::ostringstream strs;
     strs << "R" << RNS::Rey;
     RNS::Rey_str = strs.str();
   }
   else
   {
     oomph_info << "Looping Reynolds" << std::endl; 
     oomph_info << "Rey_start: " << RNS::Rey_start << std::endl; 
     oomph_info << "Rey_incre: " << RNS::Rey_incre << std::endl; 
     oomph_info << "Rey_end: " << RNS::Rey_end << std::endl; 
   }
 }

/////////////////////////////////////////////// 
 //Set up the problem
 if(RNS::myMeshType == HEXAHEDRAL)
  {
   UnstructuredFluidProblem<QTaylorHoodElement<3> > problem;

   // Setup the label. Used for doc solution and preconditioner.
   RNS::Label = RNS::Prob_str + RNS::Mesh_str
                + RNS::W_str + RNS::NS_str + RNS::F_str + RNS::P_str
                + RNS::Vis_str + RNS::Rey_str + "A" + RNS::Mesh_folder_str
                + RNS::W_approx_str + RNS::Sigma_str;

    time_t rawtime;
    time(&rawtime);

    oomph_info << "RAYDOING: "
               << RNS::Label
               << " on " << ctime(&rawtime) << std::endl;
     
    problem.distribute();
    problem.unsteady_run();
  }
 else if(RNS::myMeshType == TETRAHEDRAL)
  {
   UnstructuredFluidProblem<TTaylorHoodElement<3> > problem;

   // Setup the label. Used for doc solution and preconditioner.
   RNS::Label = RNS::Prob_str + RNS::Mesh_str
                + RNS::W_str + RNS::NS_str + RNS::F_str + RNS::P_str
                + RNS::Vis_str + RNS::Rey_str + "A" + RNS::Mesh_folder_str
                + RNS::W_approx_str + RNS::Sigma_str;

    time_t rawtime;
    time(&rawtime);

    oomph_info << "RAYDOING: "
               << RNS::Label
               << " on " << ctime(&rawtime) << std::endl;
     problem.distribute();
     problem.unsteady_run();
  }
 else
  {
   std::ostringstream err_msg;
   err_msg << "No such mesh shapes." << std::endl;

   throw OomphLibError(err_msg.str(),
                       OOMPH_CURRENT_FUNCTION,
                       OOMPH_EXCEPTION_LOCATION);
  }



   // We now output the iteration and time.
   Vector<Vector<Vector<double> > > iters_times
     = RNS::Doc_linear_solver_info_pt->iterations_and_times();

   // Below outputs the iteration counts and time.
   // Output the number of iterations
   // Since this is a steady state problem, there is only
   // one "time step".
   //*
   // Loop over the time steps and output the iterations, prec setup time and
   // linear solver time.
   unsigned ntimestep = iters_times.size();

   unsigned sum_all_its = 0;
   unsigned n_all_its = 0;
   for(unsigned intimestep = 0; intimestep < ntimestep; intimestep++)
   {
     // New timestep:
     std::cout << "RAYITS:\t" << intimestep << "\t";
     
     // Loop through the Newtom Steps
     unsigned nnewtonstep = iters_times[intimestep].size();
     unsigned sum_of_newtonstep_iters = 0;
     for(unsigned innewtonstep = 0; innewtonstep < nnewtonstep;
         innewtonstep++)
     {
       sum_of_newtonstep_iters += iters_times[intimestep][innewtonstep][0];
       sum_all_its += iters_times[intimestep][innewtonstep][0];
       n_all_its++;
       std::cout << iters_times[intimestep][innewtonstep][0] << " ";
     }
     double average_its = ((double)sum_of_newtonstep_iters)
       / ((double)nnewtonstep);

     // Print to one decimal place if the average is not an exact
     // integer. Otherwise we print normally.
     std::streamsize cout_precision = std::cout.precision();
     ((unsigned(average_its*10))%10)?
       std::cout << "\t"<< std::fixed << std::setprecision(1)
       << average_its << "(" << nnewtonstep << ")" << std::endl:
       std::cout << "\t"<< average_its << "(" << nnewtonstep << ")" << std::endl;
     std::cout << std::setprecision(cout_precision);
   }

   // Output average of all its
   {
     double average_its = ((double)sum_all_its) / ((double)n_all_its);
     std::cout <<"RAYAVGITS:\t";
     std::streamsize cout_precision = std::cout.precision();
     ((unsigned(average_its*10))%10)?
       std::cout << "\t"<< std::fixed << std::setprecision(1)
       << average_its << std::endl:
       std::cout << "\t"<< average_its << std::endl;
     std::cout << std::setprecision(cout_precision);

   }

   // Now doing the preconditioner setup time.
   for(unsigned intimestep = 0; intimestep < ntimestep; intimestep++)
   {
     // New timestep:
     std::cout << "RAYPRECSETUP:\t" << intimestep << "\t";
     // Loop through the Newtom Steps
     unsigned nnewtonstep = iters_times[intimestep].size();
     double sum_of_newtonstep_times = 0;
     for(unsigned innewtonstep = 0; innewtonstep < nnewtonstep;
         innewtonstep++)
     {
       sum_of_newtonstep_times += iters_times[intimestep][innewtonstep][1];
       std::cout << iters_times[intimestep][innewtonstep][1] << " ";
     }
     double average_time = ((double)sum_of_newtonstep_times)
       / ((double)nnewtonstep);

     // Print to one decimal place if the average is not an exact
     // integer. Otherwise we print normally.
     std::cout << "\t"<< average_time << "(" << nnewtonstep << ")" << std::endl;
   }

   // Now doing the linear solver time.
   for(unsigned intimestep = 0; intimestep < ntimestep; intimestep++)
   {
     // New timestep:
     std::cout << "RAYLINSOLVER:\t" << intimestep << "\t";
     // Loop through the Newtom Steps
     unsigned nnewtonstep = iters_times[intimestep].size();
     double sum_of_newtonstep_times = 0;
     for(unsigned innewtonstep = 0; innewtonstep < nnewtonstep;
         innewtonstep++)
     {
       sum_of_newtonstep_times += iters_times[intimestep][innewtonstep][2];
       std::cout << iters_times[intimestep][innewtonstep][2] << " ";
     }
     double average_time = ((double)sum_of_newtonstep_times)
       / ((double)nnewtonstep);

     // Print to one decimal place if the average is not an exact
     // integer. Otherwise we print normally.
     std::cout << "\t"<< average_time << "(" << nnewtonstep << ")" << std::endl;
   }



#ifdef OOMPH_HAS_MPI
// finalize MPI
MPI_Helpers::finalize();
#endif
 return(EXIT_SUCCESS); 
} // end_of_main




