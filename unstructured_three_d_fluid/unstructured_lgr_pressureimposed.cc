//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//    Version 1.0; svn revision $LastChangedRevision$
//LIC//
//LIC// $LastChangedDate$
//LIC// 
//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Driver code for a simple unstructured fluid problem using a mesh
// generated from an input file generated by the 3d mesh generator
// tetgen

#include <fenv.h>
#include <sstream>
#include <iomanip>
#include <ios>


//Generic routines
#include "generic.h"
#include "constitutive.h"
#include "navier_stokes.h"

// Get the mesh
#include "meshes/tetgen_mesh.h"
#include "meshes/brick_from_tet_mesh.h"

using namespace std;
using namespace oomph;


//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////


//=======start_namespace==========================================
/// Global variables
//================================================================
namespace Global_Parameters
{

 /// Fluid pressure on inflow boundary
 double P_in=0.5;
 double P_in_max=1.0;

 /// Fluid pressure on outflow boundary
 double P_out=-0.5;
 double P_out_max=-1.0;


 // These are the pre-sets (defaults) for problem parameters.

 /// Problem Dimension
 const unsigned Dim = 3;

 /// Switch for mesh: --use_brick
 bool Use_brick = false;

 /// Switch for linear solver type: --use_iterative_lin_solver
 bool Use_iterative_lin_solver = false;

 /// Switch for iterative linear solver: --use_trilinos
 bool Use_trilinos = false;

 /// Prec. for Navier-Stokes block: --use_lsc
 bool Use_lsc = false;

 /// Prec. for velocity block: --use_amg_for_f
 bool Use_amg_for_f = false;

 /// Use Boomer AMG for the pressure block?
 bool Use_amg_for_p = false;

 /// Using stress divergence viscous term?
 bool Use_stress_div = true;

 /// Reynolds number
 double Re = 100.0;

 /// Doc number (for doc_solution)
 unsigned Doc_num = 0;

 /// Doc directory (for doc_solution)
 std::string Doc_dir = "RESLT";

 /// Label for doc solution
 std::string Doc_label = "fluid_soln";

 /// Label for tetgen file (incl folder)
 std::string Tetgen_label = "tetgen_original/fsi_bifurcation_fluid";

 /// Number for tetgen file
 unsigned Tetgen_num = 1;

 /// Storage for number of iterations during Newton steps 
 Vector<Vector<unsigned> > Iterations;
 Vector<Vector<double> > Lin_solver_time;
 Vector<Vector<double> > Prec_setup_time;


 // New time stepping stuff.
 bool Do_unsteady = false;

 double Time_start = 0.0;
 double Time_end = 1.0;
 double Delta_t = 0.04; // 1/25

 bool Do_adapt_time = false;
 double Time_tol = 0.0001; // 10^-4

} //end namespace


namespace DriverCodeHelpers
{
inline void specify_command_line_flag_helper()
{
  // Alias the namespace for convenience.
  namespace GP = Global_Parameters;

  // Use brick mesh?
  CommandLineArgs::specify_command_line_flag("--use_brick");

  // Use iterative linear solver?
  CommandLineArgs::specify_command_line_flag("--use_iterative_lin_solver");

  // Use trilinos GMRES?
  CommandLineArgs::specify_command_line_flag("--use_trilinos");


  // Use lsc solver?
  CommandLineArgs::specify_command_line_flag("--use_lsc");

  // Use AMG for F block?
  CommandLineArgs::specify_command_line_flag("--use_amg_for_f");

  // Use AMG for P block?
  CommandLineArgs::specify_command_line_flag("--use_amg_for_p");

  // Use stress divergence viscous term?
  CommandLineArgs::specify_command_line_flag("--use_stress_div");

  // Reynolds number.
  CommandLineArgs::specify_command_line_flag("--re",&GP::Re);

  // Setting for Doc_info
  CommandLineArgs::specify_command_line_flag("--doc_dir",&GP::Doc_dir);
  CommandLineArgs::specify_command_line_flag("--doc_num",&GP::Doc_num);
  CommandLineArgs::specify_command_line_flag("--doc_label",&GP::Doc_label);
 
  // Label for tetgen file
  CommandLineArgs::specify_command_line_flag("--tetgen_label",
                                             &GP::Tetgen_label);

  // Number for tetgen file
  CommandLineArgs::specify_command_line_flag("--tetgen_num",
                                             &GP::Tetgen_num);

  CommandLineArgs::specify_command_line_flag("--do_unsteady");
  CommandLineArgs::specify_command_line_flag("--tstart",&GP::Time_start);
  CommandLineArgs::specify_command_line_flag("--tend",&GP::Time_end);
  CommandLineArgs::specify_command_line_flag("--dt",&GP::Delta_t);
  CommandLineArgs::specify_command_line_flag("--do_adapt_time");
  CommandLineArgs::specify_command_line_flag("--time_tol",&GP::Time_tol);
  
}

inline void setup_command_line_flags(DocInfo& doc_info)
{
  namespace GP = Global_Parameters;

  if(CommandLineArgs::command_line_flag_has_been_set("--use_brick"))
  {
    GP::Use_brick = true;
  }
  else
  {
    GP::Use_brick = false;
  }

  if(CommandLineArgs::command_line_flag_has_been_set(
        "--use_iterative_lin_solver"))
  {
    GP::Use_iterative_lin_solver = true;
  }
  else
  {
    GP::Use_iterative_lin_solver = false;
  }

  // Set the flag for trilinos solver
  if(CommandLineArgs::command_line_flag_has_been_set("--use_trilinos"))
  {
#ifdef OOMPH_HAS_TRILINOS
    GP::Use_trilinos = true;
#else
    std::ostringstream warning_stream;
    warning_stream << "WARNING: \n"
      << "No trilinos installed, using oomphlib's GMRES solver.\n";
    OomphLibWarning(warning_stream.str(),
      OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);

    GP::Use_trilinos = false;
#endif
  }
  else
  {
    GP::Use_trilinos = false;
  }

  if(CommandLineArgs::command_line_flag_has_been_set("--use_lsc"))
  {
    GP::Use_lsc = true;
  }
  else
  {
    GP::Use_lsc = false;
  }

  // Set the flag for amg for the momentum block
  if(CommandLineArgs::command_line_flag_has_been_set("--use_amg_for_f"))
  {
    GP::Use_amg_for_f = true;
  }
  else
  {
    GP::Use_amg_for_f = false;
  }

  // Set the flag for amg for the pressure block
  if(CommandLineArgs::command_line_flag_has_been_set("--use_amg_for_p"))
  {
    GP::Use_amg_for_p = true;
  }
  else
  {
    GP::Use_amg_for_f = false;
  }

  if(CommandLineArgs::command_line_flag_has_been_set("--use_stress_div"))
  {
    oomph_info << "Using stress divergence viscous term" << std::endl; 
    for (unsigned d = 0; d < GP::Dim; d++)
    {
      NavierStokesEquations<GP::Dim>::Gamma[d] = 1.0;
    }
  }
  else
  {
    oomph_info << "Using simple viscous term" << std::endl; 
    for (unsigned d = 0; d < GP::Dim; d++)
    {
      NavierStokesEquations<GP::Dim>::Gamma[d] = 0.0;
    }
  }
 
  if(!CommandLineArgs::command_line_flag_has_been_set("--re"))
  {
    oomph_info << "--re has not been set. Using default Re=" 
               << GP::Re << std::endl; 
  }
  
  
  if(!CommandLineArgs::command_line_flag_has_been_set("--doc_dir"))
  {
    oomph_info << "--doc_dir has not been set. Using default Doc_dir=" 
               << GP::Doc_dir << std::endl;
  }
  doc_info.set_directory(GP::Doc_dir);

  if(!CommandLineArgs::command_line_flag_has_been_set("--doc_num"))
  {
    oomph_info << "--doc_num has not been set. Using default Doc_num=" 
               << GP::Doc_num << std::endl; 
  }
  doc_info.number()=GP::Doc_num;

  if(!CommandLineArgs::command_line_flag_has_been_set("--doc_label"))
  {
    oomph_info << "--doc_label has not been set. Using default Doc_label=" 
               << GP::Doc_label << std::endl; 
  }
  doc_info.label()=GP::Doc_label;

  
  if(!CommandLineArgs::command_line_flag_has_been_set("--tetgen_label"))
  {
    oomph_info 
      << "--tetgen_num has not been set. Using default Tetgen_label=" 
      << GP::Tetgen_label << std::endl; 
  }

  if(!CommandLineArgs::command_line_flag_has_been_set("--tetgen_num"))
  {
    oomph_info << "--tetgen_num has not been set. Using default Tetgen_num=" 
               << GP::Tetgen_num << std::endl; 
  }
  else
  {
    if((GP::Tetgen_num < 1)||(GP::Tetgen_num > 13))
    {
      std::ostringstream err_msg;
      err_msg << "Tetgen_num=" << GP::Tetgen_num << "\n"
              << "Must be between 1 and 13, use --tetgen_num\n";
      throw OomphLibError(err_msg.str(),
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
    }

  }

  if(CommandLineArgs::command_line_flag_has_been_set("--do_unsteady"))
  {
    // Set the driving pressures to zero.
    GP::P_in = 0.0;
    GP::P_out = 0.0;
    GP::Do_unsteady = true;
    oomph_info << "Doing unsteady" << std::endl;
    
  }
  else
  {
    GP::Do_unsteady = false;
    oomph_info << "Doing steady state" << std::endl; 
  }

  if(GP::Do_unsteady)
  {
    if(CommandLineArgs::command_line_flag_has_been_set("--tstart"))
    {
      oomph_info << "Start time set to: "<< GP::Time_start << std::endl;
    }
    else
    {
      oomph_info << "Using default start time: "<< GP::Time_start 
                 << std::endl;
    }
  }

  if(GP::Do_unsteady)
  {
    if(CommandLineArgs::command_line_flag_has_been_set("--tend"))
    {
      oomph_info << "Set Time_end="<< GP::Time_end << std::endl;
    }
    else
    {
      oomph_info << "Using default Time_end="<< GP::Time_end
                 << std::endl;
    }
  }

  if(GP::Do_unsteady)
  {
    if(CommandLineArgs::command_line_flag_has_been_set("--dt"))
    {
      oomph_info << "Set Delta_t="<< GP::Delta_t << std::endl;
    }
    else
    {
      oomph_info << "Using default Delta_t="<< GP::Delta_t
                 << std::endl;
    }
  }

  if(CommandLineArgs::command_line_flag_has_been_set("--do_adapt_time"))
  {
    GP::Do_adapt_time = true;
    oomph_info << "Doing adaptive time stepping." << std::endl;
  }
  else
  {
    GP::Do_adapt_time = false;
    oomph_info << "Fixed time step." << std::endl; 
  }

  if(GP::Do_adapt_time)
  {
    if(CommandLineArgs::command_line_flag_has_been_set("--time_tol"))
    {
      oomph_info << "Set Time_tol="<< GP::Time_tol << std::endl;
    }
    else
    {
      oomph_info << "Using default Time_tol="<< GP::Time_tol
                 << std::endl;
    }
  }
} // setup_command_line_flags()

} // namespace DriverCodeHelpers




//======start_problem_class===========================================
/// Unstructured fluid problem
//====================================================================
template<class ELEMENT>
class UnstructuredFluidProblem : public Problem
{

public:

 /// Constructor: 
 UnstructuredFluidProblem();

 /// Destructor (empty)
 ~UnstructuredFluidProblem(){}


 /// \short Update before Newton solve.
 void actions_before_newton_solve()
 {
//   if(Global_Parameters::Use_iterative_lin_solver)
//   {
//     Global_Parameters::Iterations.clear();
//   }
 }

 /// \short Update after Newton solve.
 void actions_after_newton_solve() { }

 /// \short Update before Newton step.
 void actions_before_newton_step() {}

 /// \short Update after Newton step - document the number of iterations 
 /// required for the iterative solver to converge.
 void actions_after_newton_step()
 {
   namespace GP = Global_Parameters;

   // Get the iteration counts if using iterative linear solver
   if(Global_Parameters::Use_iterative_lin_solver)
   {
     unsigned iter = static_cast<IterativeLinearSolver*>
      (this->linear_solver_pt())->iterations();
     double prec_setup_time = static_cast<IterativeLinearSolver*>
      (this->linear_solver_pt())->preconditioner_pt()->setup_time();

     double solver_time = 0.0;
     if(GP::Use_trilinos)
     {
      TrilinosAztecOOSolver* trilinos_solver_pt 
        = dynamic_cast<TrilinosAztecOOSolver*>(this->linear_solver_pt());
      solver_time = trilinos_solver_pt->linear_solver_solution_time();
     }
     else
     {
      solver_time 
        = this->linear_solver_pt()->linear_solver_solution_time();
     }

     GP::Iterations.back().push_back(iter);
     GP::Prec_setup_time.back().push_back(prec_setup_time);
     GP::Lin_solver_time.back().push_back(solver_time);
   }
 }

 /// RRR
 void actions_before_implicit_timestep()
 {
   // Alias namespace for convenience
   namespace GP = Global_Parameters;

   // Get rid of previous time step in case it's rejected.
   if(Global_Parameters::Do_unsteady)
   {
     GP::Iterations.pop_back();
     GP::Lin_solver_time.pop_back();
     GP::Prec_setup_time.pop_back();

     GP::Iterations.push_back(Vector<unsigned>());
     GP::Lin_solver_time.push_back(Vector<double>());
     GP::Prec_setup_time.push_back(Vector<double>());
   }



   if(Global_Parameters::Do_unsteady)
   {
     const double time = time_pt()->time(); 
     const double scaling = -cos(MathematicalConstants::Pi*time)/2.0 + 0.5;
     Global_Parameters::P_in = Global_Parameters::P_in_max*scaling;
     Global_Parameters::P_out = Global_Parameters::P_out_max*scaling;
   }
 }

 /// RRR
 void actions_after_implicit_timestep(){}

 /// RRR
 void actions_before_adapt(){}

 /// RRR
 void actions_after_adapt(){}

 /// RRR
 void actions_before_distribute() {}

 /// RRR
 void actions_after_distribute() {}


 /// Doc the solution
 void doc_solution(DocInfo& doc_info);
 
 /// Return total number of fluid inflow traction boundaries
 unsigned nfluid_inflow_traction_boundary()
  {
   return Inflow_boundary_id.size();
  }

 /// Return total number of fluid outflow traction boundaries
 unsigned nfluid_outflow_traction_boundary()
  {
   return Outflow_boundary_id.size();
  }

 /// Return total number of fluid outflow traction boundaries
 unsigned nfluid_traction_boundary()
  {
   return Inflow_boundary_id.size()+Outflow_boundary_id.size();
  }

 /// Create Lagrange multiplier elements that enforce parallel outflow
 void create_parallel_outflow_lagrange_elements();

 /// TODO
 double global_temporal_error_norm();

 /// TODO
 void unsteady_run();

 //private:


 /// Set a direction for the first tangent vector.
 Vector<double> Tangent_direction;

 /// Create fluid traction elements at inflow
// void create_fluid_traction_elements();

 /// Bulk fluid mesh
 Mesh* Fluid_mesh_pt;

 /// \short Meshes of FaceElements imposing parallel outflow 
 /// and a pressure at the in/outflow
 Vector<Mesh*> Parallel_outflow_lagrange_multiplier_mesh_pt;

 Mesh* Combined_surface_mesh_pt;

 /// \short IDs of fluid mesh boundaries along which inflow boundary conditions
 /// are applied
 Vector<unsigned> Inflow_boundary_id;

 /// \short IDs of fluid mesh boundaries along which inflow boundary conditions
 /// are applied
 Vector<unsigned> Outflow_boundary_id;

 /// Preconditioner (master Lagrange Enforced Flow Preconditioner)
 Preconditioner* Prec_pt;

 /// Preconditioner for the Navier-Stokes block
 Preconditioner* Navier_stokes_prec_pt;

 /// Preconditioner for the momentum block
 Preconditioner* F_preconditioner_pt;

 /// Preconditioner for the pressure block
 Preconditioner* P_preconditioner_pt;

 /// Iterative linear solver
 IterativeLinearSolver* Solver_pt;

};



//==========start_constructor=============================================
/// Constructor for unstructured 3D fluid problem
//========================================================================
template<class ELEMENT>
UnstructuredFluidProblem<ELEMENT>::UnstructuredFluidProblem()
{ 

 // first set up the time stepper:
 if(Global_Parameters::Do_adapt_time)
 {
   oomph_info << "RAYINFO: Adding adding adaptive BDF2" << std::endl;
   add_time_stepper_pt(new BDF<2>(true));
 }
 else if(Global_Parameters::Do_unsteady)
 {
   oomph_info << "RAYINFO: Adding adding fixed BDF2" << std::endl;
   add_time_stepper_pt(new BDF<2>);
 }
 else
 {
   oomph_info << "RAYINFO: Doing steady state" << std::endl;
 }


 // Set up the tetgen files.
 std::stringstream ss;
 ss<<Global_Parameters::Tetgen_num;

 //Create fluid bulk mesh, sub-dividing "corner" elements
 string node_file_name=Global_Parameters::Tetgen_label
                       +"."+ss.str()+".node";
 string element_file_name=Global_Parameters::Tetgen_label
                          +"."+ss.str()+".ele";
 string face_file_name=Global_Parameters::Tetgen_label
                       +"."+ss.str()+".face";
 bool split_corner_elements=true;


 // Create the mesh
 if(Global_Parameters::Do_unsteady)
 {
   if(Global_Parameters::Use_brick)
   {
     Fluid_mesh_pt = new BrickFromTetMesh<ELEMENT>(node_file_name,
          element_file_name,
          face_file_name,
          split_corner_elements,
          time_stepper_pt());
   }
   else
   {
     Fluid_mesh_pt =  new TetgenMesh<ELEMENT>(node_file_name,
                                              element_file_name,
                                              face_file_name,
                                              split_corner_elements,
                                              time_stepper_pt());
   }
 }
 else
 {
   if(Global_Parameters::Use_brick)
   {
     Fluid_mesh_pt = new BrickFromTetMesh<ELEMENT>(node_file_name,
          element_file_name,
          face_file_name,
          split_corner_elements,
          time_stepper_pt());
   }
   else
   {
     Fluid_mesh_pt =  new TetgenMesh<ELEMENT>(node_file_name,
                                              element_file_name,
                                              face_file_name,
                                              split_corner_elements,
                                              time_stepper_pt());
   }
 }


 // Find elements next to boundaries
 Fluid_mesh_pt->setup_boundary_element_info();

 // The following corresponds to the boundaries as specified by
 // facets in the tetgen input:

 // Fluid mesh has one inflow boundary: Boundary 0
 Inflow_boundary_id.resize(1);
 Inflow_boundary_id[0]=0;
 
 // Fluid mesh has two outflow boundaries: Boundaries 1 and 2
 Outflow_boundary_id.resize(2);
 Outflow_boundary_id[0]=1;
 Outflow_boundary_id[1]=2;

 // Create meshes of Lagrange multiplier elements at inflow/outflow
 //----------------------------------------------------------------

 // Create the meshes
 unsigned n=nfluid_traction_boundary();
 Parallel_outflow_lagrange_multiplier_mesh_pt.resize(n);
 for (unsigned i=0;i<n;i++)
  {
   Parallel_outflow_lagrange_multiplier_mesh_pt[i]=new Mesh;
  } 
 
 Tangent_direction.resize(3,0);
 Tangent_direction[0] = 0;
 Tangent_direction[1] = 1;
 Tangent_direction[2] = 0; 
 
 // Populate them with elements
 create_parallel_outflow_lagrange_elements();

 // Combine the lot
 //----------------
 
 // Add sub meshes:

 // Fluid bulk mesh
 add_sub_mesh(Fluid_mesh_pt);
 
 // The fluid traction meshes
 n=nfluid_traction_boundary();
 for (unsigned i=0;i<n;i++)
  { 
   add_sub_mesh(Parallel_outflow_lagrange_multiplier_mesh_pt[i]);
  }
 
 // Build global mesh
 build_global_mesh();

 // Apply BCs
 //----------
 unsigned nbound=Fluid_mesh_pt->nboundary();

 // Vector indicating the boundaries where we have no slip
 std::vector<bool> pin_velocity(nbound, true);
 
 // Loop over inflow/outflow boundaries
 for (unsigned in_out=0;in_out<2;in_out++)
  {
   // Loop over in/outflow boundaries
   n=nfluid_inflow_traction_boundary();
   if (in_out==1) n=nfluid_outflow_traction_boundary();
   for (unsigned i=0;i<n;i++)
    {
     // Get boundary ID
     unsigned b=0;
     if (in_out==0)
      {
       b=Inflow_boundary_id[i];
      }
     else
      {
       b=Outflow_boundary_id[i];
      }
     
     pin_velocity[b]=false;
    }

  } // done identification of boundaries where velocities are pinned

 // Loop over all boundaries to apply no slip where required
 for(unsigned b=0;b<nbound;b++)
  {
   if(pin_velocity[b])
    {
     unsigned num_nod=Fluid_mesh_pt->nboundary_node(b);
     for (unsigned inod=0;inod<num_nod;inod++)
      {
       Node* nod_pt=Fluid_mesh_pt->boundary_node_pt(b,inod);

       // Pin all velocities
       nod_pt->pin(0); 
       nod_pt->pin(1); 
       nod_pt->pin(2); 
       
       // Find out if the node is also located on an in- or outflow
       // boundary
       bool is_in_or_outflow_node=false;
       for (unsigned in_out=0;in_out<2;in_out++)
        {
         // Loop over boundaries with Lagrange multiplier elements
         n=nfluid_inflow_traction_boundary();
         if (in_out==1) n=nfluid_outflow_traction_boundary();
         for (unsigned i=0;i<n;i++)
          {
           // Get boundary ID
           unsigned bb=0;
           if (in_out==0)
            {
             bb=Inflow_boundary_id[i];
            }
           else
            {
             bb=Outflow_boundary_id[i];
            }
           
           if(nod_pt->is_on_boundary(bb))
            {
             is_in_or_outflow_node=true;
            }
          }
        } // now we know if it's on the an in- or outflow boundary...


       // If its on an in- or outflow boundary pin the Lagrange multipliers
       if(is_in_or_outflow_node)
        {
         //Cast to a boundary node
         BoundaryNodeBase *bnod_pt = 
          dynamic_cast<BoundaryNodeBase*>
          (Fluid_mesh_pt->boundary_node_pt(b,inod) );
         
         // What's the index of the first Lagrange multiplier
         // in the node's values? 
         unsigned first_index=bnod_pt->index_of_first_value_assigned_by_face_element();
         
         // Pin the lagrange multiplier components 
         // in the out/in_flow boundaries
         for (unsigned l=0;l<2;l++)
          {
           nod_pt->pin(first_index+l);
          }
        }
      }
    }
  } // end of BC 

 // Complete the build of the fluid elements so they are fully functional
 //----------------------------------------------------------------------
 unsigned n_element = Fluid_mesh_pt->nelement();
 for(unsigned e=0;e<n_element;e++)
  {

   // Upcast from GeneralisedElement to the present element
   ELEMENT* el_pt = dynamic_cast<ELEMENT*>(Fluid_mesh_pt->element_pt(e));
   
   //Set the Reynolds number
   el_pt->re_pt() = &Global_Parameters::Re;   
   el_pt->re_st_pt()=&Global_Parameters::Re;

  } 

 // Setup equation numbering scheme
 std::cout <<"Number of equations: " << assign_eqn_numbers() << std::endl; 

 ///////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////

 // Now we create and setup the solvers.

 // Are we using an iterative linear solver?
 if(Global_Parameters::Use_iterative_lin_solver)
 {
  // We choose either trilinos or oomph-lib's GMRES as our linear solver
  if(Global_Parameters::Use_trilinos)
  {
#ifdef OOMPH_HAS_TRILINOS
    // Create the trilinos solver.
    TrilinosAztecOOSolver* trilinos_solver_pt = new TrilinosAztecOOSolver;
    trilinos_solver_pt->solver_type() = TrilinosAztecOOSolver::GMRES;

    // Store the solver pointer.
    Solver_pt = trilinos_solver_pt;
#endif
  }
  else
  {
    // Create oomph-lib iterative linear solver.
    IterativeLinearSolver* solver_pt = new GMRES<CRDoubleMatrix>;
    
    // We use RHS preconditioning. Note that by default,
    // left hand preconditioning is used.
    static_cast<GMRES<CRDoubleMatrix>*>(solver_pt)
      ->set_preconditioner_RHS();

    // Store the solver pointer.
    Solver_pt = solver_pt;
  }

  // Set tolerance
  Solver_pt->tolerance() = 1.0e-6;

 
 // Create the preconditioner
 LagrangeEnforcedFlowPreconditioner* lgr_prec_pt
   = new LagrangeEnforcedFlowPreconditioner;

 // Use this thing.
 ///  Mesh(const Vector<Mesh*>& sub_mesh_pt)

 Combined_surface_mesh_pt 
   = new Mesh(Parallel_outflow_lagrange_multiplier_mesh_pt);


 // Create the vector of mesh pointers
 Vector<Mesh*> mesh_pt;
 mesh_pt.resize(2,0);
 mesh_pt[0] = Fluid_mesh_pt;
 mesh_pt[1] = Combined_surface_mesh_pt;

 // Set the meshes
 lgr_prec_pt->set_meshes(mesh_pt);

 // Setup subsidiary preconditioner for the Navier-Stokes block.
  NavierStokesSchurComplementPreconditioner* lsc_prec_pt = 0;
  if(Global_Parameters::Use_lsc)
  {
    // Create the NS LSC preconditioner.
    lsc_prec_pt = new NavierStokesSchurComplementPreconditioner(this);
    lsc_prec_pt->set_navier_stokes_mesh(Fluid_mesh_pt);
    lsc_prec_pt->use_lsc();
    lgr_prec_pt->set_navier_stokes_preconditioner(lsc_prec_pt);

    // Use AMG for f block?
    if(Global_Parameters::Use_amg_for_f)
    {
      F_preconditioner_pt
        = Lagrange_Enforced_Flow_Preconditioner_Subsidiary_Operator_Helper::
          boomer_amg_for_3D_momentum();
        lsc_prec_pt->set_f_preconditioner(F_preconditioner_pt);
    }
 
    // Use AMG for p block?
    if(Global_Parameters::Use_amg_for_p)
    {
      P_preconditioner_pt
        = Lagrange_Enforced_Flow_Preconditioner_Subsidiary_Operator_Helper::
          boomer_amg_for_3D_poisson_problem();
      lsc_prec_pt->set_p_preconditioner(P_preconditioner_pt);
    }
  }
  else
  {
    lgr_prec_pt->set_superlu_for_navier_stokes_preconditioner();
  }

  // Store the preconditioner pointers.
  Navier_stokes_prec_pt = lsc_prec_pt;
  Prec_pt = lgr_prec_pt;

  // Pass the preconditioner to the solver.
  Solver_pt->preconditioner_pt() = lgr_prec_pt;

  // Max linear solver iterations.
  Solver_pt->max_iter() = 300;

  // Pass the solver to the problem.
  this->linear_solver_pt() = Solver_pt;

  // Set the Newton solver tolerance.
  this->newton_solver_tolerance() = 1.0e-6;

 }
 
} // end constructor

//============start_of_lagrange_multiplier_elements======================
/// Create Lagrange multiplier elements that impose parallel outflow
//=======================================================================
template<class ELEMENT>
void UnstructuredFluidProblem<ELEMENT>::
create_parallel_outflow_lagrange_elements()
{
 // Counter for number of Lagrange multiplier meshes
 unsigned count=0;

 // Loop over inflow/outflow boundaries
 for (unsigned in_out=0;in_out<2;in_out++)
  {
   // Loop over boundaries with Lagrange multiplier elements
   unsigned n=nfluid_inflow_traction_boundary();
   if (in_out==1) n=nfluid_outflow_traction_boundary();
   for (unsigned i=0;i<n;i++)
    {
     // Get boundary ID
     unsigned b=0;
     if (in_out==0)
      {
       b=Inflow_boundary_id[i];
      }
     else
      {
       b=Outflow_boundary_id[i];
      }
     
     // How many bulk elements are adjacent to boundary b?
     unsigned n_element = Fluid_mesh_pt->nboundary_element(b);
     
     // Loop over the bulk elements adjacent to boundary b
     for(unsigned e=0;e<n_element;e++)
      {
       // Get pointer to the bulk element that is adjacent to boundary b
       ELEMENT* bulk_elem_pt = dynamic_cast<ELEMENT*>(
        Fluid_mesh_pt->boundary_element_pt(b,e));
       
       //What is the index of the face of the element e along boundary b
       int face_index = Fluid_mesh_pt->face_index_at_boundary(b,e);
       
       // Build the corresponding lagrange element
       ImposeParallelOutflowElement<ELEMENT>* el_pt = new 
        ImposeParallelOutflowElement<ELEMENT>(bulk_elem_pt,face_index);
       
       el_pt->set_tangent_direction(&Tangent_direction);
       // Add it to the mesh
       Parallel_outflow_lagrange_multiplier_mesh_pt[count]->
        add_element_pt(el_pt);
       
       // Set the pointer to the prescribed pressure
       if (in_out==0)
        {
         el_pt->pressure_pt()= &Global_Parameters::P_in;
        }
       else
        {
         el_pt->pressure_pt()= &Global_Parameters::P_out;
        }
      }
     // Bump up counter
     count++;
    }
  }

}  // done


//========================================================================
/// Doc the solution
//========================================================================
template<class ELEMENT>
void UnstructuredFluidProblem<ELEMENT>::doc_solution(DocInfo& doc_info)
{ 
 // Create the file name string.
 std::stringstream filename;
 filename << doc_info.directory() 
           << "/"
          <<doc_info.label()<<doc_info.number()<<".dat";

 // Number of plot points
 unsigned npts=5;

 // Output solution
 std::ofstream some_file;
 some_file.open(filename.str().c_str());
 Fluid_mesh_pt->output(some_file,npts);
 some_file.close();
}

template<class ELEMENT>
double UnstructuredFluidProblem<ELEMENT>::global_temporal_error_norm()
{
#ifdef OOMPH_HAS_MPI
double global_error = 0.0;

// Find out how many nodes there are in the problem.
unsigned n_node = Fluid_mesh_pt->nnode();

// Loop over the nodes and calculate the estimate error in the values
// for non-haloes
int count = 0;
for (unsigned nod_i = 0; nod_i < n_node; nod_i++) 
{
  Node* nod_pt = Fluid_mesh_pt->node_pt(nod_i);
  if(!(nod_pt->is_halo()))
  {
    // Get the error in solution: Difference between the predicted and
    // actual value for nodal values 0, ... dim-1
    double node_error = 0.0;
    for (unsigned nodal_i = 0; nodal_i < Global_Parameters::Dim; nodal_i++) 
    {
      double error = nod_pt->time_stepper_pt()->
        temporal_error_in_value(nod_pt,nodal_i);
      node_error += error*error;
      count++;
    } // for loop over the nodal values 0,..,dim-1
    global_error += node_error;
  } // if the node is not halo
} // for loop over nodes

// Accumulate
int n_node_local = count;
int n_node_total = 0;

MPI_Allreduce(&n_node_local,&n_node_total,1,MPI_INT,MPI_SUM,
    this->communicator_pt()->mpi_comm());

double global_error_total = 0.0;
MPI_Allreduce(&global_error,&global_error_total,1,MPI_DOUBLE,MPI_SUM,
    this->communicator_pt()->mpi_comm());

// Divide by the number of nodes
global_error_total /= double(n_node_total);

// Return square root...
return sqrt(global_error_total);
#else
double global_error = 0.0;

// Find out how many nodes there are in the problem
unsigned n_node = Fluid_mesh_pt->nnode();

// Loop over the nodes and calculate the errors in the values.
for (unsigned node_i = 0; node_i < n_node; node_i++) 
{
  Node* nod_pt = Fluid_mesh_pt->node_pt(node_i);

  // Get the error in the solution: Difference between predicted and 
  // actual value for nodal values 0,..,dim-1
  double nodal_error = 0.0;
  for (unsigned nodal_i = 0; nodal_i < Global_Parameters::Dim; nodal_i++) 
  {
    double error = nod_pt->time_stepper_pt()->
      temporal_error_in_value(nod_pt,nodal_i);

    // Add the squared value to the nodal error.
    nodal_error += error*error;
  }

  // add the nodal error to the global error.
  global_error += nodal_error;
}

global_error /= double(n_node*Global_Parameters::Dim);

// Return square root
return sqrt(global_error);
#endif
} // EoF global_temporal_error_norm


template<class ELEMENT>
void UnstructuredFluidProblem<ELEMENT>::unsteady_run()
{
  // Alias namespace for convenience
  namespace GP = Global_Parameters;

  double dt = GP::Delta_t;

  // Initialise all history values for an impulsive start
  this->assign_initial_values_impulsive(dt);
  oomph_info << "RAYINFO: IC = Impulsive start" << std::endl;

  unsigned current_time_step = 0;

//  if(Doc_soln_flag)
//  {
//    doc_solution(mesh_pt,soln_dir_str,label_str,current_time_step);
//  }
//
//
  double time_tol = GP::Time_tol;

//
while(this->time_pt()->time() < GP::Time_end)
{
  oomph_info << "TIMESTEP: " << current_time_step << std::endl;

  // Setup storage for a new time step
  if(Global_Parameters::Do_unsteady)
  {
    // Initialise counters for each newton solve.
    Global_Parameters::Iterations.push_back(Vector<unsigned>());
    Global_Parameters::Prec_setup_time.push_back(Vector<double>());
    Global_Parameters::Lin_solver_time.push_back(Vector<double>());
  }

  if (GP::Do_adapt_time)
  {
    oomph_info << "DELTA_T: " << dt << std::endl;

    // Calculate the next time step.
    dt = this->adaptive_unsteady_newton_solve(dt,time_tol);
  }
  else
  {
    // Take one fixed time step
    this->unsteady_newton_solve(dt);
  }

  oomph_info << "Time is now: " 
    << this->time_pt()->time() << std::endl;

//  if(Doc_soln_flag)
//  {
//    doc_solution(mesh_pt,soln_dir_str,label_str,current_time_step);
//  }
  current_time_step++;
}




} // unsteady_run




void format_avgits_avgnewtonsteps_ntimesteps
(const Vector<Vector<unsigned> >* iters_pt,
 std::ostringstream* results_stream_pt)
{
  namespace GP = Global_Parameters;

  // Loop through all the time steps.
  const unsigned ntimestep = GP::Iterations.size();

  unsigned total_nnewton_step = 0;

  unsigned total_its = 0;
  unsigned n_total_its = 0;

  for(unsigned intimestep = 0; intimestep < ntimestep; intimestep++)
  {
      // Loop through the Newton Steps
      unsigned nnewtonstep = (*iters_pt)[intimestep].size();
      total_nnewton_step += nnewtonstep;

      for(unsigned innewtonstep = 0; innewtonstep < nnewtonstep;
          innewtonstep++)
      {
        total_its += (*iters_pt)[intimestep][innewtonstep];
        n_total_its++;
      }
    }

    double average_its = ((double)total_its)
      / ((double)n_total_its);

    double average_n_newton_step = ((double)total_nnewton_step)
      / ((double)ntimestep);

    (*results_stream_pt) << "RAYAVGAVGITS:\t";
    std::streamsize tmp_precision = results_stream_pt->precision();
    (*results_stream_pt) << "\t" << std::fixed << std::setprecision(1)
      << average_its << "(" << average_n_newton_step << ")"
      << "(" << ntimestep << ")\n";

    // reset the precision
    (*results_stream_pt) << std::setprecision(tmp_precision);
}



//=============start_main=================================================
/// Demonstrate how to solve an unstructured 3D fluids problem
//========================================================================
int main(int argc, char **argv)
{
#ifdef OOMPH_HAS_MPI
  MPI_Helpers::init(argc,argv);
#endif

  // Store command line arguments
  CommandLineArgs::setup(argc,argv);

  DriverCodeHelpers::specify_command_line_flag_helper();

  // Parse the above flags.
  CommandLineArgs::parse_and_assign();
  CommandLineArgs::doc_specified_flags();

  // Label for output
  DocInfo doc_info;

  // Set up flags
  DriverCodeHelpers::setup_command_line_flags(doc_info);


  if(Global_Parameters::Use_brick)
  {
    //Set up the problem
    UnstructuredFluidProblem<QTaylorHoodElement<3> > problem;

    if(Global_Parameters::Do_unsteady)
    {
      problem.unsteady_run();
    std::ostringstream results_stream;

    format_avgits_avgnewtonsteps_ntimesteps(&Global_Parameters::Iterations,
                                            &results_stream);

    // Create an out file.
    // The output file.
    std::ofstream outfile;

    // If we want to output to a file, we create the outfile.
    std::ostringstream filename_stream;
    filename_stream <<"res_iterations/iter"
      << Global_Parameters::Doc_num;
    outfile.open(filename_stream.str().c_str());

    outfile << "\n" << results_stream.str();
    outfile.close();

    }
    else
    {
    // Solve the problem
    problem.newton_solve();

    std::ostringstream results_stream;

    format_avgits_avgnewtonsteps_ntimesteps(&Global_Parameters::Iterations,
                                            &results_stream);

    // Create an out file.
    // The output file.
    std::ofstream outfile;

    // If we want to output to a file, we create the outfile.
    std::ostringstream filename_stream;
    filename_stream <<"res_iterations/iter"
      << Global_Parameters::Doc_num;
    outfile.open(filename_stream.str().c_str());

    outfile << "\n" << results_stream.str();
    outfile.close();

    }



  }
  else
  {
    //Set up the problem
    UnstructuredFluidProblem<TTaylorHoodElement<3> > problem;

    //Output initial guess
    // problem.doc_solution(doc_info);
    // doc_info.number()++;

    // Solve the problem
    problem.newton_solve();

    std::ostringstream results_stream;
//    print_avg_iter(&Global_Parameters::Iterations,
//        &results_stream);

    // Create an out file.
    // The output file.
    std::ofstream outfile;

    // If we want to output to a file, we create the outfile.
    std::ostringstream filename_stream;
    filename_stream <<"res_iterations/iter"
      << Global_Parameters::Doc_num;
    outfile.open(filename_stream.str().c_str());

    outfile << "\n" << results_stream.str();
    outfile.close();
  }

#ifdef OOMPH_HAS_MPI
  MPI_Helpers::finalize();
#endif  


} // end_of_main




